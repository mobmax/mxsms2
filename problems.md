# Проблемы SMPP-протокола из песочницы

В мире сложно найти что-либо идеальное. Протокола SMPP также не лишен некоторых изъянов. Опишу свои проблемы с этим протоколом. Надеюсь кому-то это поможет в принятии правильных решений.

**Первый**, самый проблемный недостаток: потеря `message_id` при разрыве соединения. Страдают от этого операции отправки (`submit_sm` и т.п.) для которых не успел прийти ответ. Протокол не содержит встроенных средств восстановления утерянных идентификаторов. Как следствие, когда придет статус сообщения, его не к чему привязать. Более того, неизвестно принял ли это сообщение SMSC.
Если обмен осуществляется в синхронном режиме, то потеряется только одно сообщение. Но если работа производится в асинхронном режиме, тогда потери могут быть существенными.

Этот недостаток SMPP, пожалуй, единственный нерешаемый средствами протокола из тех, которые я могу припомнить. Проблема, конечно, решается но не стандартизованными методами.

Остальные недостатки связаны с проблемами реализации. Их решении, как правило, заключается в достижении договоренности между SMSC и SMPP-клиентом и не выходит за рамки спецификации. 

**Второй** недостаток, который мне сильно досаждает, связан с отчетам о доставке `deliver_sm`. В версии протокола 3.4 нет строго определения как должна передаваться статусная информация. С одной стороны есть необязательная структура TLV в которой в жестко типизированной форме передается message_state и сопутствующие параметры. Это вариант хорош, за исключением того, что SMSC не сможет выслать в этой структуре какой-нибудь пространный комментарий. Но, повторюсь, нигде этот способ не указан как обязательный (MUST). Зато в приложении к протоколу приведен пример. Подчеркиваю: ПРИМЕР. Даже не рекомендация. Пример того, как SMSC может сообщать статусную информацию через (о боже, кто это придумал!!!) поле `short_message`. Т.е. в текстовом виде, странные сокращения, дикие форматы и т.д. 

Вообще, это ситуация выбора одного из возможных вариантов (MAY). По моим представления о реализации протоколов выбор одного из разрешенных протоколом варианта — прерогатива формирующей пакет стороны. В данном случае с пакетом отчета это SMSC. А принимающая сторона обязана правильно обработать любой пакет соответствующий протоколу. Но суровая реальность говорит, что прав тот кто платит. Подавляющее большинство SMPP-клиентов понимают только поле `short_message`. 

Славо богу из спецификации пятой версии протокола убрали эту мину (приложение), но найдите-ка SMPP-клиентов пятой версии.

**Третий** недостаток — передача длинных сообщений. Спецификация ненавязчиво ссылается на стандарт [GSM 03.40] Technical Realisation of the Short Message Service Point to Point». Так ненавязчиво, что замечаешь ссылку только когда ищешь специально. Ссылка на этот стандарт приведена в разделе 1.4 References спецификации версии 3.4.

_Вопрос:_ поле `short_message` предполагается протоколом использовать только в соответствии с GSM 03.40? GSM 03.40 предлагает длинный текст сообщения разбивается на серию конкатенированных sms, снабженных UDH-заголовками. Спецификация SMPP неявно подстегивает на свободное использование — длина поля 254 октетов. Это две sms латиницей или почти четыре sms кириллицей.

Читаем внимательно спецификацию SMPP:

>4.4.1 “SUBMIT_SM” Syntax
>«… Up to 254 octets of short message user data. The exact physical limit for short_message size may vary according to the underlying network… »

Т.е. ограничения накладываются передающей сетью (underlying network). В нашем случае underlying network описывается GSM 03.40. Следовательно 140 байт данных. Зачем же такое длинное поле? Дело в том что использоваться может 7-bit кодировка, тогда символов уже 160. `short_message` это текстовое поле измеряющееся в октетах, а не бинарное в байтах. Возможно, создатели закладывались и на другие, более изощренные варианты.

Разработчик SMPP-клиента по понятным причинам хочет упростить себе задачу. И не стремится на своей стороне связываться c конкатенированными SMS. В соответствии с протоколом SMSC МОЖЕТ предоставлять такую услугу через поле `message_payload` (самостоятельно делить сообщение на смски, снабжать заголовками) в форме по своему выбору (не стандартизировано). Но по протоколу не обязан. Да и применять это можно без страха только к обычным текстовым сообщениям. С точки зрения бизнеса вопрос тоже скользкий — как тарифицировать такие сообщения? А что если не все части сообщения имеют статус доставлено?

**Четвертый** недостаток связан с относительным форматом времени. Относительного чего отмерять указанное время? Когда нет задержек ни на клиенте ни на SMSC и между ними хорошая связь, вопросов, как правило, не возникает. Но если в каком-то месте появляется задержка, то точки отсчета времени клиента и SMSC существенно расходятся.

Для `schedule_delivery_time` в разделе 5.2.15 уточняется:

>"..relative time from the current SMSC time at which delivery of this message will be attempted by the SMSC.."

Но проблему разных точек отсчета это не решает.

---

Разбивка на части -- это самый надежный способ. Он гарантированно будет работать на всех SMSC.

При разбивке на части есть два варианта оформления фрагментов:

1. вставка Concatenated Short Message (8bit или 16bit) Header в UDH каждого фрагмента. 100% надежный способ, должен работать везде;
2. использование TLV `sar_msg_ref_num`, `sar_segment_seqnum`, `sar_total_segments`. Здесь, на мой взгляд, есть следующие нюансы:
	a) не все SMSC смогут поддерживать эти TLV. В жизни встречаются самописные SMPP-шлюзы, которые поддерживают только подмножество SMPP и не умеют работать с данными TLV;
	b) насколько я помню GSM 03.40, заголовок конкатенированного сообщения в летящем на телефон пакете располагается именно в UDH. Т.е. формируя `submit_sm`/`data_sm` PDU нужно позаботиться, чтобы в `short_message`/`message_payload` было оставлено место для заголовка. Т.е. нельзя передавать тело длиной 140 байт, поскольку в него не поместиться Concatenated Short Message 8bit Reference Numbers заголовок.

Длинные сообщения (превышающие 140/160 символов, в зависимости от кодировки), в принципе, можно передавать и в `short_message` (до 255 символов), и в `message_payload`. Как отреагирует на это SMSC -- вопрос открытый, зависящий от производителя SMSC.

Я сам не знаю, как различные SMSC будут присылать `delivery_receipt`-ы на сообщения, отправленные через `message_payload`. По стандарту SMPP (версий 3.4 и 5.0) в `delivery_receipt`-е не присутствуют какие-либо стандартизированные поля (те же `sar_msg_ref_num`, `sar_segment_seqnum`, `sar_total_segments`), которые относились бы к конкретным фрагментам. Исходя из этого стоит ожидать один `delivery_receipt`.

Но, для совместимости со старыми версиями SMPP в `delivery_receipt`-е присутствует `short_message` вида:

	id:IIIIIIIIII sub:SSS dlvrd:DDD submit date:YYMMDDhhmm done
	date:YYMMDDhhmm stat:DDDDDDD err:E Text: . . . . . . . . .

где текстовые поля `sub` и `dlvrd` указывают, сколько сообщений было отосланно и сколько было доставлено. По логике, для длинного SMS в `message_payload` эти поля будут содержать информацию о том, сколько фрагментов было отосланно и сколько доставлено. Но какие именно фрагменты были доставлены узнать вряд ли получится.

---

Для отправки длинных сообщений (более 140 октетов) есть как минимум два способа - резать сообщение на части, при этом сообщение записывается в поле `short_message` и заполняются tlv: `sar_msg_ref_num`, `sar_total_segments`, `sar_segment_seqnum`.

Способ 1.5 - вместо использования `sar_*` данные о конкатенации/сегментах сообщения пишутся в само тело сообщения (так называемый UDH). Про UDH можно прочитать в wikipedia - http://en.wikipedia.org/wiki/Concatenated_SMS (кажется это самый древний и самый часто встречаемый способ).

Второй способ - записываем всё сообщение в опциональное поле (TLV) `message_payload`. Самый простой способ, но стоит убедиться, что ваш SMSC поддерживает эту возможность.

Подробнее можно почитать в спецификации на SMPP - http://docs.nimta.com/SMPP_v3_4_Issue1_2.pdf

Про кодировку - в SMPP используется UCS2, а не UTF-16. Разница в том, что UCS2 является кодировкой с фиксированной длинной и поддерживает только Plane 0, в то время как UTF-16 variable length. Чем это грозит - пока вам необходимо кодировать символы с Plane 0 (Basic Multilingual Plane) - результаты кодирования в utf16 и ucs2 будут совпадать (всегда ли?). Если вам захочется закодировать пару египетских иероглифов, математическую формулу или emoji, то результаты окажутся разными.

---

1. Default Alphabet (GSM 3.38), 7-bit characters - maximum of 160 characters;
2. Latin 1 (ISO-8859-1), 8-bit characters - limit is 140 characters;
3. Unicode (UTF16/USC-2), 16-bit characters - limit is 70 characters;

- Кодировка для сообщений на латинице: GSM 03.38, длина одного сообщения 160 символов. Запрещенные символы: `^`,`{`,`}`,`\`,`[`,`]`,`~`,`|`,`€`
- Кодировка для сообщений на кириллице: UTF16, длина одного SMS сообщения составляет 70 символов
- Отправка длинных (склеенных) сообщений возможна с использованием UDH или message_payload;
- При отправке SMS с UDH необходимо установить соответствующее значение ESM_class=0x40, DCS устанавливается согласно тексту и может быть UCS2 (ISO/IEC-10646) (0x08) для Unicode кодировки и DCS=0x00 для GSM-default кодировки.
  
  UDH представляет собой следующее: 

  	a. 0x05
	b. 0x00
	c. 0x03
	d. 1 октет - уникальный для данной группы SMS номер
	e. 1 октет - количество SMS для склейки
	f. 1 октет - порядковый номер SMS


- При формировании длинных сообщений больше 160 символов латиницей и 70 кириллицей, длина сообщения составляет:
	- Латиница - Default Alphabet (GSM 3.38):
	- 1 SMS -
		160 символов;
		153 * 2 = 306 симв.;
		459 симв. и т.д.
		70 символов;
		67 *2 = 134 симв.;
		201 симв.; 268 и т.д.


---

	$SMS="Concatenated message. This long message which is necessary for cutting, transferring and pasting together. The message is written by Umnikov Alexander. http://www.isms.ru"; 
	@text_in=split(/(.{153})/,$SMS); 

	use SMPP; 

	($smpp_t,$err) = Net::SMPP->new_transmitter( 
	        "192.168.0.0", 
	        port=>"2775", 
	        system_id => 'isms.ru', 
	        password => 'isms.ru', 
	        system_type=>'isms.ru' 

	        ) or die; 

	print"Connect-transmitter. Status=",$err->{status},"*\n"; 

	for($i=0;$i<=$#text_in;$i++) 
	{ 

	$resp = $smpp_t->submit_sm( 
	        protocol_id=>0x00, 
	        validity_period=>'', 
	        source_addr_ton => 0x05, 
	        source_addr_npi => 0x00, 
	        source_addr => 'isms.ru', 
	        dest_addr_ton => 0x01, 
	        dest_addr_npi => 0x01, 
	        destination_addr => '71111111111', 
	        data_coding => 0x00, 
	        short_message=> 
	"\x05\x00\x03\xA9".chr($#text_in+1).chr($i+1).&scl(0,$text_in[$i]), 
	        esm_class => 0x40, 
	        priority_flag =>3, 
	        ); 
	print "\$resp-$tm\n"; 
	foreach $each (keys(%$resp)) 
	{ 
	print "[$each]-[$resp->{$each}]\n"; 
	} 

	} 

	sub scl 
	{ 
	my ($dcs,$s)=@_; 
	if($dcs== 0x08){return $s}; 
	$s=&pack_7bit(("\x00"x7).$s); 
	$s=~ /^\x00\x00\x00\x00\x00\x00(.*)/; 
	return $1 
	} 

	sub pack_7bit { 
	        my ($s) = @_; 
	        $s = unpack 'b*', $s; 
	        $s =~ s/(.{7})./$1/g; 
	        return pack 'b*', $s; 
	} 
	sub unpack_7bit { 
	        my ($s) = @_; 
	        $s = unpack 'b*', $s; 
	        $s =~ s/(.{7})/${1}0/g; 
	        $s = pack 'b*', $s; 
	        chop $s if substr($s, -1, 1) eq "\x00"; 
	        return $s; 
	} 

---

